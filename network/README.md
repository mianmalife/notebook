## HTTP协议
1. 超文本传输协议(超媒体文档如HTML)
2. 应用层协议
3. 为Web浏览器,Web服务器之间通讯而设计
4. 客户端-服务端模型(客流端发送请求,然后等待直到收到消息)
5. 无状态协议(服务器在两个请求之间不保留任何数据状态)
6. 基于TCP/`IP`协议
7. Web数据交换的基础
8. 客户端-服务端协议


- 客户端(用户代理,一般是浏览器，也可以是其它,  比如机器爬虫)发起请求
- 浏览器发起请求并解析HTTP返回的消息
- Web服务器为客户端提供文档
- 浏览器和服务器之间存在代理,用来转发HTTP消息
  
## HTTP性质
1. 简单, 报文易读(虽然HTTP/2将HTTP消息封装到了帧中)
2. 可扩展
3. 无状态有会话(使用cookies可以创建有状态的会话)

## HTTP和连接
- 客户端和服务端交互之前必须在这两者间建立一个TCP链接, 每一对都是如此,因此相比多个请求复用一个TCP连接更低效
  
## HTTP控制内容
1. 缓存
2. 代理和隧道
3. 认证
4. 开发同源限制
5. 会话

## HTTP流
1. 打开一个TCP连接
2. 发送一个HTTP报文
   ```
    GET / HTTP/1.1
    Host: developer.mozilla.org
    Accept-Language: fr
   ```
3. 读取服务端返回的报文信息
   ```
    HTTP/1.1 200 OK
    Date: Sat, 09 Oct 2010 14:28:02 GMT
    Server: Apache
    Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
    ETag: "51142bc1-7449-479b075b2891b"
    Accept-Ranges: bytes
    Content-Length: 29769
    Content-Type: text/html

   ```
  4. 关闭连接或者为后续请求重用连接
   
## HTTP报文

1. 请求
   ```
    GET / HTTP/1.1
    Host: developer.mozilla.org
    Accept-Language: fr
   ```


2. 响应
   ```
    HTTP/1.1 200 OK
    Date: Sat, 09 Oct 2010 14:28:02 GMT
    Server: Apache
    Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
    ETag: "51142bc1-7449-479b075b2891b"
    Accept-Ranges: bytes
    Content-Length: 29769
    Content-Type: text/html
   ```

## 基于HTTP的APIs
  ```
  XMLHttpRequest, Fetch API
  ```

## HTTP状态码
- 信息响应(100~199)
- 成功响应(200~299)
- 重定向消息(300~399)
- 客户端错误响应(400~499)
- 服务端错误响应(500~599)

  ```
  301: 永久重定向
  302: 临时重定向
  303: 指示客户端通过一个GET请求在另一个URL中获取请求的资源
  304: 客户端继续使用缓存

  400: 客户端错误,无效请求参数等
  401: 请求的资源需身份验证
  403: 没有访问权限(与401不同的是, 服务器知道客户端身份)
  404: 服务器找不到资源
  405: 目标资源不支持该方法

  500: 服务器遇到不知如何处理的情况
  501: 服务器不支持请求方法
  502: 服务器作为网关需要得到一个处理这个请求的响应,但是得到一个错误的响应
  503: 服务没有准备好处理请求,比如服务器维护或停机
  504: 服务器充当网关响应超时
  ```
## HTTP headers

- 通用首部
- 请求头
- 响应头
- 实体头

## 跨域资源共享[CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)
- 基于HTTP请求头的机制
- 服务器标示了除过它以外的域,允许浏览器访问自己的资源


### 简单请求
- GET
- POST
- HEAD(请求头部信息, 这些头部信息与GET请求返回的头部信息一致) 在一些大文件下载请求中 返回资源的大小信息,以决定是否下载

### 处理简单的跨域请求

服务端设置 `Access-Control-Allow-Origin: http://xxx...` 和客户端`Origin: http://xxx...`配合

### 预检请求

比如一个POST请求设置了自定义头和Content-Type

浏览器发起OPTIONS请求 -> 服务端响应 -> 浏览器发起实际请求(比如POST) -> 服务端响应

## HTTP响应首部字段

   ```
   // 服务端告诉客户端不同的域返回不同的内容
   Access-Control-Allow-Origin: http://xxx
   Vary: http://xxx

   // 将服务端允许访问的头放入白名单
   Access-Control-Expose-Headers: X-kaka-Headers X-hh-Headers

   // 预检请求的结果缓存多久
   Access-Control-Max-Age: 86400   // 24小时

   // 设置预检请求的响应 允许实际请求的HTTP方法
   Access-Control-Allow-Methods: GET, POST

   ...

   ```
   
## HTTPS

`HTTP`传递信息是以明文的形式发送内容, 所以HTTPS出现了, `HTTPS = HTTP + SSL/TLS`, 通过`SSL`证书来验证服务器的身份,  并为浏览器和服务器之间的通信进行加密
(`SSL`: 安全套接字协议, `TLS`: 传输层安全)
区别
`HTTPS` 默认端口`443` `HTTP`默认端口是80
`HTTP`不安全, `HTTPS`相对安全
`HTTPS`需要设计加密及多次握手, 性能不如`HTTPS`
`HTTPS`需要`SSL`证书, `SSL`证书需要钱, 功能越强大的越贵

## HTTPS如何保证安全?

- 混合加密 -> 对称加密+非对称加密

1. 机密性: 混和算法
2. 完整性: 摘要算法
3. 身份认证: 数字签名
4. 不可否定: 数字签名
5. 引入第三方证书, 确保公开秘钥的安全性

## UDP
`User Datagram Protocol` 用户数据包协议 简单的面向数据报的通信协议

## TCP
`Transmission Control Protocol` 传输控制协议 面向字节流的通信协议
把上面应用层交下来的数据看成无结构的字节流来发送

## TCP/IP协议

传输控制协议/网际协议, 由`FTP`, `SMTP`, `TCP`, `UDP`, ``IP``等协议组成的协议簇
因为最具代表性, 所以这样称呼

划分 两种

1. 五层体系
   - 应用层
   - 传输层
   - 网络层
   - 数据链路层
   - 物理层
2. 四层体系
   - 应用层
   - 传输层
   - 网际互连层(网络层)
   - 网络接口层


区别

| | TCP | UDP |
| :---: | :---: | :---: |
| 可靠性 | 可靠 | 不可靠 |
| 连接性 | 面向连接 | 无连接 |
| 报文 | 面向字节流| 面向报文 |
| 效率 | 传输效率低 | 传输效率高 |
| 双共性 | 全双工 | 一对一,一对多,多对一,多对多 |
| 流量控制 | 滑动窗口 | 无 |
| 拥塞控制 | 慢开始, 拥塞避免, 快重传, 快恢复| 无 |
|传输效率| 慢 | 快 |

在应用层交互的数据称为报文

使用场景
- `TCP`: 效率要求低, 准确性要求高的有链接场景(电子邮件, 远程终端接入, HTTP...)
- `UDP`: 效率要求高, 准确性要求低的场景(域名转换(DNS)...)
  
## OSI
(开放式通信系统互联参考模型)

1. 应用层
2. 表示层
3. 会话层
4. 传输层
5. 网络层
6. 数据链路层
7. 物理层

## DNS协议

DNS指域名系统 解析域名为`IP`的服务器

域名
`www.xxx.com`
`www`: 三级域名
`xxx:` 二级域名
`com`: 顶级域名
根域名.省略了, 因为系统为用户做了兼容

`DNS`查询方式

- 递归查询 a请求b b去找
- 迭代查询 a请求b b没有 b告诉a去找c要...

## 域名缓存
- 浏览器缓存域名和实际的`IP`地址
- 操作系统缓存, 比如用户自己配置的host

## DNS完整查询过程
递归查询&迭代查询

- 浏览器`DNS`缓存中查找
- 操作系统缓存中查找
- 本地域名服务器`DNS`缓存中查找
- 本地域名服务器请求根域名服务器
- 根域名服务器返回顶级域名服务器地址给本地域名服务器
- 本地域名服务器根据顶级域名服务器地址请求到权限域名服务器地址
- 本地域名服务器向权限域名服务器发起请求, 最终得到域名对应``IP``地址, 返回给操作系统, 自己缓存``IP``地址
- 操作系统将`IP`地址返回给浏览器, 自己缓存`IP`地址
- 浏览器得到域名与对应的`IP`地址, 将`IP`缓存起来

## CDN

内容分发网络, 根据用户位置分配最近的资源
用户不直接访问源站, 访问最近的一个`CDN`结点->边缘节点, 其实就是缓存了源站内容的代理服务器
